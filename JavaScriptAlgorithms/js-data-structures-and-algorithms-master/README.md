# 자바스크립트 알고리즘

## 목차

[1장. 빅오 표기법](#1장-빅오-표기법)
[2장. 자바스크립트 특징](#2장-자바스크립트-특징)
[3장. 자바스크립트 숫자](#3장-자바스크립트-숫자)

## 1장. 빅오 표기법

[예제](<./Chapter1(Big-O%20Notation).js>)

> 빅오 표기법은 알고리즘의 최악의 경우 복잡도를 측정한다.  
> 빅오 표기법에서 n은 입력의 개수를 나타낸다.

![빅오 표기법](Big_O.png)

O(1) : 상수 시간 (ex) `for(let i=0; i < 1000; i++)`  
O(log n) : 로그 시간 (ex) `for(let i=0; i < n; i * 2)`  
O(n) : 선형 시간  
O(n^2) : 2차 시간  
O(n^3) : 3차 시간  
O(n^n) : n차 시간  
O(∞) : 무한 루프 (ex) `while(true)`

### 빅오 표기법 규칙

- 계수 법칙 : 입력 크기와 연관되지 않는 상수 무시 => 계수/상수 제거
- 합의 법칙 : 동일한 블록 레벨의 시간복잡도를 더할 수 있다. => 빅오 더하기
- 곱의 법칙 : 중첩된 블록의 시간복잡도를 곱할 수 있다. => 빅오 곱하기
- 다항 법칙 : f(n)이 k차 다항식이면 f(n) = O(n^k) => 루프를 조사해 빅오 표기법의 다항 결정
- 전이 법칙

(ex) 숫자와 관계 없이 n번 더한 후 1번 더하면 n + 1 | 시간 복잡도 : O(n)  
(ex) 반복문이 5\*n 까지면 f(n) = 5n, n까지면 f(n) = n | 시간 복잡도 : O(n)  
(ex) f(n) = 5n^2 | 시간 복잡도 : O(n^2)

## 2장. 자바스크립트 특징

[예제](<./Chapter2(UniqueParts).js>)

> `var` : 변수를 어디서(블록 내부) 선언하든 함수의 맨 앞으로 이동한다.  
> 단, false인 조건문은 건너 뛴다.

- `typeof 연산자`를 배열에 사용해도 `object`를 반환한다.
- 기본 등가 확인 연산자인 `==`과 `===`는 문자열, 숫자, 불리언 같은 비객체형에만 사용할 수 있다. 객체에 대한 등가 확인을 구현하려면 객체의 각 속성을 확인해야 한다.

### 참/거짓

- false로 평가되는 경우 : `false`, `NaN`, `0`, `undefined`, 빈 문자열(`''`, `""`), `null`
- true로 평가되는 경우 : `true`, 비어 있지 않은 문자열, 0이 아닌 다른 숫자, 비어 있지 않은 객체

## 3장. 자바스크립트 숫자

[예제](<./Chapter3(Numbers).js>)

> 자바스크립트의 모든 숫자는 64비트 부동소수점 형태이다.  
> 십진분수로 인해 자바스크립트에서 부동소수점 체계가 반올림 오류를 일으킬 수 있다.

```javascript
0.1 + 0.2 === 0.3; // false
```

- 가능한 가장 작은 부동소수점 증가를 얻기 위해서는 `Number.EPSILON` 을 사용해야 한다.
- `Number.EPSILON` : 두 개의 표현 가능한 숫자 사이의 가장 작은 간격을 반환한다.

### 자바스크립트 숫자 범위

- `Number.MAX_VALUE` : 가능한 가장 큰 부동 소수점 반환
  - -> `1.7976931348623157e + 308`
- `Number.MAX_SAFE_INTEGER` : 가장 큰 정수 반환
  - => 서로 다른 소수를 더한 값은 같지 않다.
- `Number.MIN_VALUE` : 가능한 가장 작은 부동 소수점 반환
  - => 음수가 아닌 0에 가장 가까운 부동소수점
  - -> `5e - 324`
  ```javascript
  Number.MIN_VALUE - 1 == -1; // true
  ```
- `Number.MIN_SAFE_INTEGER` : 가장 작은 정수 반환
  - => 서로 다른 소수를 뺀 값은 같지 않다.
  - -> `-9007199254740991`

```
-Infinity < Number.MIN_SAFE_INTEGER < Number.MIN_VALUE < 0 < Number.MAX_SAFE_INTEGER < Number.MAX_VALUE < Infinity
```

### 숫자 알고리즘

> 가장 효율적인 규칙을 찾는 것 => 가장 좋은 알고리즘의 비결

#### 1. 소수

> 암호화와 해싱의 기반이 된다.

**[알고리즘]**

- ⓐ 2와 3을 제외한 모든 소수는 `6k ± 1`의 형태를 지닌다.
- ⓑ n의 제곱근이 소수가 아닌 정수라면 n은 소수가 아니다.
- **시간 복잡도 : O(sqrt(n))**

```javascript
function isPrime(n) {
  if (n <= 1) return false;
  if (n <= 3) return true;

  // 입력된 수가 2 또는 3인 경우 아래 반복문에서
  // 다섯 개의 숫자를 건너뛸 수 있다.
  if (n % 2 == 0 || n % 3 == 0) return false;

  for (var i = 5; i * i <= n; i = i + 6) {
    if (n % i == 0 || n % (i + 2) == 0) return false;
  }

  return true;
}
```

#### 2. 소인수분해

> 주어진 숫자를 만들기 위한 소수들의 곱

**[알고리즘]**

1. n을 2로 나눌 수 있는 만큼 나눈다. (2 출력)
2. i를 2씩 증가시키며 n을 나눌 수 있는 만큼 i로 나눈다. (i 출력)
3. n이 2보다 크다면 n을 출력한다.

- **시간 복잡도 : O(sqrt(n))**

```javascript
function primeFactors(n) {
  // n이 2로 나눠진다면 나눠질 수 있는 수만큼 2가 출력된다.
  while (n % 2 == 0) {
    console.log(2);
    n = n / 2;
  }

  // 이 지점에서 n은 홀수임이 확실하다. 따라서 수를 두 개씩 증가시킬 수 있다(주목: i = i + 2).
  for (var i = 3; i * i <= n; i = i + 2) {
    // i가 n을 나눌 수 있는 한 계속해서 i가 출력되고 n을 i로 나눈다.
    while (n % i == 0) {
      console.log(i);
      n = n / i;
    }
  }
  // 다음 조건문은 n이 2보다 큰 소수인 경우를 처리하기 위한 것이다.
  if (n > 2) {
    console.log(n);
  }
}
```

#### 3. 무작위 수 생성

> 어떤 조건이 어떤 식으로 동작하는지 확인

- `Math.random()` : 0과 1 사이의 부동소수점 반환
  - 범위 변경 : 범위에 해당하는 숫자를 연산
  - 무작위 정수 : `Math.floor()`, `Math.round()`, `Math.ceil()`

#### 4. 모듈러 제곱거듭

> 컴퓨터 과학, 공개키 암호화 알고리즘 분야에서 사용된다.

- `(x^y) % p` : x는 기저, y는 지수, p는 모듈러
- 강력한 암호의 경우 기저가 최소 256비트(78개 수)
- -> `Math.pow()`로는 32비트 부동소수점까지만 저장할 수 있어 실제로 활용하기 어렵다.

**[수학적 속성]** : 1부터 지수까지 순회하면서 현재 모듈러를 마지막 모듈러와 곱함으로써 매번 재계산 가능

```
c % m = (a b) % m
c % m = [(a % m)(b % m)] % m
```

**[의사코드]**

1. `값 = 1` 로 설정한다. 현재 지수는 0이다.
2. 현재 지수를 1만큼 증가시킨다.
3. 현재 지수가 목표 지수가 될 때까지 `값 = (값 * 기저) mod 모듈러` 로 설정한다.

- **시간 복잡도 : O(n)**

```javascript
function modularExponentiation(base, exponent, modulus) {
  if (modulus == 1) return 0;

  var value = 1;

  for (var i = 0; i < exponent; i++) {
    value = (value * base) % modulus;
  }
  return value;
}
```
